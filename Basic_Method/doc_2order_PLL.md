# どうして `int_err` から **ω̂<sub>e</sub>** を計算しているのか？

---

## 1. ループの役割分担を整理する

| ブロック | 連続時間の伝達関数 | 役割 | 位相誤差を 0 にするために必要な積分器数 |
|----------|------------------|------|----------------------------------------|
| 位相比較器 (PD) | *e* = $I_{h\delta}$ ∝ $\sin\!\Delta\theta$ | 位相誤差 $\Delta\theta$ → 誤差信号 *e* | 0 |
| ループフィルタ (PI) | $F(s)=K_p+K_i/s$ | 誤差 *e* → 周波数補正 $\Delta\omega$ | **+1** |
| VCO / NCO | $1/s$ | 周波数 → 位相 | **+1** |

結果として **2 個の積分器**（PI 内部 1 個 + VCO 1 個）を直列に持つ **2 次 PLL** になる。

> **ポイント**  
> 誤差 → 周波数補正 → 位相、という 2 段階設計なので  
> **PI 内で積分した量は「位相」ではなく「周波数（角速度）補正」に変換して使う**。

---

## 2. 離散実装での変数の次元を確認

| 変数 | 数式 | 単位 | 意味 |
|------|------|------|------|
| `err` | $e_k = I_{h\delta,k}$ | A (電流) | 位相誤差に比例する観測量 |
| `int_err` | $\displaystyle \sum e_k T_s$ | A · s | **誤差の積分値** |
| `omega_est` | $K_p e_k + K_i \,\text{int\_err}$ | rad/s | **推定角速度 (VCO 制御量)** |
| `theta_est` | $\displaystyle \sum \omega_{\text{est},k} T_s$ | rad | 推定位相 |

* $K_p$ [rad/(A·s)]、$K_i$ [rad/(A·s²)] を設定すれば `omega_est` は正しい角速度になる。  
* `theta_est` は **ω̂<sub>e</sub>** をさらに積分（NCO 部）して得る。

---

## 3. `int_err → θ̂` に直結すると？

`int_err` をそのまま θ̂ に使うと **積分器が 1 段しか無い 1 次 PLL** となり，  
速度オフセットやドリフトがあると定常位相誤差を消せない。

---

## 4. コードの流れを式でまとめる

離散時間 $k$ ステップで

\[
\begin{aligned}
e_k &= I_{h\delta,k}\\[4pt]
I_k &= I_{k-1} + e_k T_s \quad (\text{int\_err})\\[4pt]
\hat\omega_{e,k} &= K_p\,e_k + K_i\,I_k\\[4pt]
\hat\theta_{e,k} &= \hat\theta_{e,k-1} + \hat\omega_{e,k}\,T_s
\end{aligned}
\]

* $I_k$ — PI フィルタ内の **位相誤差の積分**  
* $\hat\omega_{e,k}$ — **NCO に与える角速度補正値**  
* $\hat\theta_{e,k}$ — **最終的な位相推定値**

---

## 5. まとめ

* `int_err` は「位相誤差の時間積分」を保持するだけ。  
* **Ki** を掛けて **rad/s** にスケール変換し，**Kp** と加算して  
  **推定角速度 ω̂<sub>e</sub>** を得る。  
* その角速度を **もう一度積分** して初めて **θ̂** になる。  
* 積分器 2 段の **2 次 PLL** が位相追従性能・定常誤差除去に必要。

---
